Analysis of "VMAdventures 1"

  Inside the main function (0x710 bytes from the start of the static file), the
user is prompted to enter a password. The password and its length are passed
as parameters to a function that performs operations on the bytes of the
password string.

  The function that performs operations on the bytes of the password string is
located 0x570 bytes from the start of the static file. The password length is
moved to the EDX register and the password string address is moved to the
ESI register. A zero is moved to a 1 byte local variable. This variable will
be checked in every iteration of the loop that follows. If it is found to not
be zero, the loop will be exited and the function will return.

  The loop will iterate over a 16 element byte array. The elements in the array
determine which operations to perform on the password string. A switch
statement is responsible for taking the current element in the array and
selecting the operations. The 16 element byte array is seen below. 

  [ 1, 3, 4, 2, 1, 3, 2, 1, 2, 1, 3, 2, 3, 4, 2, 3 ]

  A pseudo C representation of each case and the operations performed on the
string are seen below.

0:
  ch = 1; // local byte variable the loop checks for not zero

1:
  for (i = 0; i < password length; ++i) {
    password[i] ^= 0x54;
  }

2:
  for (i = 0; i < password length; ++i) {
    password[i] ^= 0x24;
  }

3:
  for (i = 0; i < password length; ++i) {
    password[i] = ((password[i] << 2) & 0xfc) | ((password[i] >> 6) & 3);
  }

4:
  for (i = 0; i < password length; ++i) {
    password[i] += 0xeb;
  }

  Note that when we enter back in main and identify the length of the password
string this is irrelevant, but the length of the password is checked in every
case except 0. For cases 1 and 2 if the length is less than or equal to zero
and the EAX register (zero for the check) is greater than or equal to the
password length, a continue statement is effectively performed for that loop
iteration. If the password length is greater than or equal to 64, the vector
equivalent of the XOR operations are performed on each byte of the string. This
done by loading a hardcoded sixteen byte string with either 0x54 for case 1 or
0x24 for case 2 for all 16 bytes into the XMM2 register and loading the XMM
registers with 16 byte chunks of the password string. The two strings are then
XOR'd using the PXOR operation. The result then replaces the sixteen byte chunk
of the password string used in the operation. The 16 bytes chunks are offset 0,
offset 16, offset 32, and offset 48 from a pointer to the password's address.
The pointer is initialized to the password string's address and incremented by
64 with each iteration of the vector XOR operations. This is performed the
password length divided 64 times (integer division). If the password length is
not a multiple of 64, the remaining bytes of the string have the operations
described in the switch statement cases (case 1 and case 2) above performed.

  Cases 3 and 4 simply perform a continue if the password length is less than
or equal to zero.

  When the loop concludes, the function returns and we re-enter main. The
password length is checked to be equal to 32. If it is not 32, the "Wrong
key... :(" message is output. If it is equal to 32, a loop checks each byte
of the now modified password string. Each iteration compares the byte at the 
current index in the password string to the byte at the same index in a string
starting at 0x22e0 from the start of the static file. If a byte is found to not
be equal, the loop is exited and the "Wrong key... :(" message is output. If
the loop completes after checking all 32 bytes, the "Correct key!" message is
output.

Reversing the Algorithm

  Knowing the string to compare the password to after peforming the operations
on the password, the simplest approach is to run the operations in reverse
order and with the inverse of each operation on the comparison string bytes.
The byte array for the operations is seen below.

  [ 1, 3, 4, 2, 1, 3, 2, 1, 2, 1, 3, 2, 3, 4, 2, 3 ]

Flipping the order in reverse generates the array below.

  [ 3, 2, 4, 3, 2, 3, 1, 2, 1, 2, 3, 1, 2, 4, 3, 1 ]

Note for the actual implementation of the program to generate the correct
password, I am just going to index the array starting at 15 and decrement by 1
until the loop index is less than 0.

  The following pseudo C code will be used for each case statement in the
switch statement used to reverse the operations.

1:
  for (i = 0; i < password length; ++i) {
    password[i] ^= 0x54;
  }

2:
  for (i = 0; i < password length; ++i) {
    password[i] ^= 0x24;
  }

3:
  for (i = 0; i < password length; ++i) {
    password[i] =  ((password[i] << 6) & 0xc0) | ((password[i] >> 2) & 0x3f);
  }

4:
  for (i = 0; i < password length; ++i) {
    password[i] -= 0xeb;
  }

  XOR operations are simple in that performing the same operation against the
same value twice will result in the original value for the other value. The
case 3 operation performs the ROR instruction to reverse the ROL instruction
performed. In a higher level language, there will need to be something like the
bitwise operations I show here to simulate that instruction (to my knowledge
without dropping into inline assembly). The case 4 uses subtraction to reverse
the addition.

  Setting up a loop to iterate over the reverse order operations byte array and
placing a switch statement with the cases described above in the loop body is
a very simple approach to generate the correct password. Using the comparison
string as the input into the loop, the loops completion will generate the
string, "flag{Welcome to VMAdventures :)}". This is the correct password to
generate the "Correct key!" message.

  Attached is a C source file, crack.c, that is an implementation of the
reversing steps described above.

